# Docker

## Containers and Images

A **container** is a standard unit of software that packages up code and all of its dependencies so the application runs quickly and reliably from one computing environment to another.

Containers are used to isolate software from its environment.

An **image** is an inert, immutable file that is essentially a snapshot of a container. Images are created with the `build` command, and a container is produced when images are `run`. Images are designed to be layered on top of one another, as otherwise they'd become quite large.

A container is a running instance of an image. 

A **Dockerfile** is a set of instructions for building an image. So you can share a Dockerfile, someone else uses it to build an image, and then they run the image to get a container.

## Volumes

**Volumes** are a mechanism for persisting data generated by and used by Docker containers. Volumes are completely managed by Docker and thus are independent of the underlying architecture.

The most basic volume is a **named volume**. Just a bucket of data that Docker manages for us. 

Create one with`docker volume create volume-name`

List volumes `docker volume ls`

Get info about a volume `docker volume inspect volume-name`

Remove `docker volume rm volume-nm`

Mount a volume when running a container `docker run -v volume-name:/etc/data_folder image-name`

We can also use **bind mounts** to control the exact mountpoint on the host. Most commonly this is to mount source code into container.

`docker run -v "$(pwd):/app" image-name`

This command mounts the current host directory into the `/app` directory of the container.

## Basic Commands

`docker ps` lists containers

`docker stop` stops a container

`docker rm` removes a container



### `build`

`docker build [options] PATH | URL | -`

The `PATH` or `URL` part just tells `build` where to look for the Dockerfile. 

The only common option is `-t` to "tag" the image, basically giving it a human readable name.

The most common incantation is `docker build -t image-name .`

### `run`

`docker run [options] image-name [command]` 

`docker run` produces a container from an image. 

The `command` portion allows you to run a command in the container after it's up. 

Some common options:

`-d` runs it in "detached" mode

`-p` lets you map ports in container to ports on host. Like `docker -p 3000:3000 image-name`

`-w` changes the working directory inside the container

## Multi-container Apps

We sometimes want to separate different functional pieces of our apps into different containers. In order for those separate pieces to communicate we need to introduce **container networking**.

In order to "run a container on the network" we have to create a network for it to run on. 

`docker network create network-name`

Then when we want to add a container to the network we just specify that when we run it.

```
docker run -d \
	--network network-name --network-alias mysql \
	-v cont-mysql-data:/var/lib/mysql \
	-e MYSQL_ROOT_PASSWORD=secret \
	-e MYSQL_DATABASE=cont \
	mysql:5.7
```

To confirm it's up we can connect `docker exec -it CONTAINER_ID mysql -u root -p`

The `network-alias` option above gives us a hostname we can connect to.

## Docker Compose

Docker Compose is a tool that helps us define and share multi-container applications. With compose we create a YAML file to define the services we need and spin everything up or down with a single command.

Example compose file:

```
version: "3.7"

services:
  app:
    image: node:12-alpine
    command: sh -c "yarn install && yarn run dev"
    ports:
      - 3000:3000
    working_dir: /app
    volumes:
      - ./:/app
    environment:
      MYSQL_HOST: mysql
      MYSQL_USER: roo
      MYSQL_PASSWORD: secret
      MYSQL_DB: todos

  mysql:
    image: mysql:5.7
    volumes:
      - todo-mysql-data:/var/lib/mysql
    environment:
      MYSQL_ROOT_PASSWORD: secret
      MYSQL_DATABASE: todos

volumes:
  todo-mysql-data:
```

Spin up: `docker-compose up -d`

Tear down: `docker-compose down`

## Pelican Container

Everything it does now. Plus

* Making and activating the virtualenv for pelican
* Install en, fr, tr locales - `sudo apt-get install language-pack-XX` 
* install pandoc `sudo apt-get install pandoc` 
* Install man

